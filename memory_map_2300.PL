#!perl
#
# memory_map_2300.PL - creates a MemoryMap.pm
#
use strict;
use warnings;

# ExtUtils::MakeMaker invokes us, via make, with the first arg
# pointing to the name of our destination file.
my $mmap = shift || die "Usage: $0 PATH-TO-MEMORY-MAP-PM-FILE\n";
my $tmpfile = "$mmap.tmp.$$";
unlink $tmpfile;
open my $mmap_fh, '>', $tmpfile
    or die "Cannot create $tmpfile: $!\n";

# Get the 'canonical_name' function from Open2300.pm.  We can't just 'do'
# or 'require' the module, because the xs might not exist yet.
(my $pm = $mmap) =~ s!/[^/]+(\.pm)$!$1!;

my $func_buffer = '';
open my $pm_in, '<', $pm
    or die "Cannot read $pm: $!\n";
while (my $line = <$pm_in>) {
    if ($line =~ /^sub\s+_canonical_name/) {
	$func_buffer .= $line;
    }
    elsif ($func_buffer) {
	$func_buffer .= $line;
	if ($line =~ /^\}/) {
	    close $pm_in;
	    last;
	}
    }
}
eval $func_buffer;
die "$0: $@" if $@;

# Read in the memory map...
(my $mapfile = $0) =~ s!^(.*/)?(.*)\.PL$!$2.txt!;
open IN, "<$mapfile"
  or die "Cannot read $mapfile: $!";

my @map;
my %macro;
my $previous_address;
while (my $line = <IN>) {
    chomp $line;
    $line =~ s/\s+$//;			# Remove trailing whitespace

    # E.g. 0019 0   alarm set flags
    if ($line =~ s!^([0-9a-f]{4})\s+[0-9a-f]\s*!!i) {
	my $address = hex($1);

	# This is not expected to trigger: check the sequence
	if (defined $previous_address) {
	    $address == $previous_address+1
	      or die sprintf("$mapfile:$.: Error between %04X and %04X",
			     $previous_address, $address);
	}
	$previous_address = $address;

	# Anything in plain parentheses, at the end, is a comment:
	#    0266 4    | LCD contrast: $BCD+1 (Read Only: ....)
	# strip it off.
	$line =~ s/\s*\(.*\)$//;

	# Is it a definition line?
	if ($line =~ m!^\|\s+([^ 0-9].*?)\s*:\s*(.*)!) {
	    my ($desc, $formula) = ($1, $2);
	    push @map, {
			desc => $desc,
			name => _canonical_name($desc),
			address => $address,
			length => 1,
			   };

	    # FIXME: formula
	    $formula =~ s{<(\S+)>}{
		my $key = $1;
		defined $macro{$key}
		  or die "$mapfile:$.: Undefined macro <$key>";
		$macro{$key};
	    }ge;

	    if ($formula =~ s/\s*\[(.*)\]\s*//) {
		$map[-1]->{units} = $1;
	    }

	    $map[-1]->{formula} = $formula;
	}
	elsif ($line =~ m!^_/!) {
	    my $l = $address - $map[-1]->{address} + 1;
	    if ($l > 10) {
		die "$mapfile:$.: preposterous length";
	    }
	    $map[-1]->{length} = $l;
	}
    }
    elsif ($line =~ /^\s*macro \s+ (\S+) \s+ = \s+ (\S.*\S)/x) {
	$macro{$1} = $2;
    }
    else {
	# FIXME: check for macro definition lines
    }
}
close IN;

#
# ...write out the map file...
#
print { $mmap_fh } <<'END_MMAP_HEADER';
# -*- perl -*-
#
###############################################################################
# This file is autogenerated by $0.  DO NOT EDIT!
###############################################################################
#
package Device::LaCrosse::WS23xx::MemoryMap;

use strict;
use warnings;

my $_memory_map = <<'END_MEMORY_MAP';
END_MMAP_HEADER

for my $entry (@map) {
    my $name = $entry->{name};
    if (my $units = $entry->{units}) {
	$name .= " [$units]";
    }

    printf { $mmap_fh } "%04X:%-2d %-40s %s\n", @{$entry}{"address","length"},
      $name, $entry->{formula};
}

print { $mmap_fh } <<"END_MMAP_REST";
END_MEMORY_MAP

# FIXME: split and parse
# FIXME: include canonical_name ?
# FIXME: POD

1;
END_MMAP_REST

close $mmap_fh
    or die "$0: Error writing $mmap: $!\n";
chmod 0444 => $mmap;
rename $tmpfile => $mmap
    or die "$0: could not rename $tmpfile: $!\n";

exit 0;
